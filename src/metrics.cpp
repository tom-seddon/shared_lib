#include <shared/system.h>
#include <shared/metrics.h>
#include <shared/debug.h>
#include <memory>
#include <vector>
#include <string>

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

static std::unique_ptr<std::vector<TimerDef *>> g_all_root_timer_defs;

static std::vector<TimerDef *> *GetAllRootTimerDefs() {
    if (!g_all_root_timer_defs) {
        g_all_root_timer_defs = std::make_unique<std::vector<TimerDef *>>();
    }

    return g_all_root_timer_defs.get();
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

std::vector<const TimerDef *> GetRootTimerDefs() {
    const std::vector<TimerDef *> *defs = GetAllRootTimerDefs();
    return std::vector<const TimerDef *>(defs->begin(), defs->end());
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void ResetTimerDefs() {
    for (TimerDef *def : *GetAllRootTimerDefs()) {
        def->Reset();
    }
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

TimerDef::TimerDef(std::string name_, TimerDef *parent)
    : name(std::move(name_))
    , m_parent(parent) {
    if (m_parent) {
        m_parent->m_children.push_back(this);
    } else {
        if (!g_all_root_timer_defs) {
            g_all_root_timer_defs = std::make_unique<std::vector<TimerDef *>>();
        }

        GetAllRootTimerDefs()->push_back(this);
    }
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

TimerDef::~TimerDef() {
    // this can probably be arranged using (for example) a shared_ptr, with
    // each TimerDef having its own reference, but this hardly seems worth the
    // bother...

    //    std::vector<TimerDef *> *list;
    //    if(m_parent) {
    //        list=&m_parent->m_children;
    //    } else {
    //        list=g_all_root_timer_defs.get();
    //    }
    //
    //    auto it=std::find(list->begin(),list->end(),this);
    //    ASSERT(it!=list->end());
    //    list->erase(it);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void TimerDef::Reset() {
    m_total_num_ticks = 0;
    m_num_samples = 0;

    for (TimerDef *child_def : m_children) {
        child_def->Reset();
    }
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

uint64_t TimerDef::GetTotalNumTicks() const {
    return m_total_num_ticks.load(std::memory_order_acquire);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

uint64_t TimerDef::GetNumSamples() const {
    return m_num_samples.load(std::memory_order_acquire);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void TimerDef::AddTicks(uint64_t num_ticks) {
    m_total_num_ticks.fetch_add(num_ticks, std::memory_order_acq_rel); //m_total_num_ticks += num_ticks;
    m_num_samples.fetch_add(1, std::memory_order_acq_rel);             //++m_num_samples;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

const TimerDef *TimerDef::GetParent() const {
    return m_parent;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

size_t TimerDef::GetNumChildren() const {
    return m_children.size();
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

const TimerDef *TimerDef::GetChildByIndex(size_t index) const {
    ASSERT(index < m_children.size());
    return m_children[index];
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
